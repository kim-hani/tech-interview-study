
# JPA (Java Persistence API)

---

## 1. JPA란?

JPA(Java Persistence API)는 **자바 ORM(Object-Relational Mapping) 기술의 표준 명세**이다.  
객체 지향 프로그래밍 언어(Java)와 관계형 데이터베이스(RDB)의 **패러다임 불일치(Paradigm Mismatch)** 를 해결하기 위해 만들어졌다.  

즉, **SQL을 직접 작성하지 않고도 자바 객체 중심으로 데이터베이스를 다룰 수 있게 해주는 기술**이다.  
Hibernate, EclipseLink, DataNucleus 등의 구현체가 JPA 표준을 기반으로 동작한다.

---

## 2. 왜 JPA를 사용하는가?

- **SQL 중심 개발의 한계**
  - 객체 지향적 모델링이 SQL에 의해 깨짐 (객체 → 테이블 변환 작업 필요)
  - DAO마다 중복되는 CRUD SQL 작성
  - DB 교체 시 SQL 재작성 필요

- **JPA의 장점**
  - SQL 작성 없이 객체 중심 개발 가능
  - DB 벤더에 독립적 (MySQL → Oracle 전환 시 코드 수정 최소)
  - 영속성 컨텍스트를 통한 캐싱, 변경 감지, 쓰기 지연 등 성능 최적화
  - 유지보수성 향상 — 필드 추가·변경 시 객체만 수정하면 반영 가능

---

## 3. ORM(Object-Relational Mapping)이란?

ORM은 **객체와 데이터베이스 테이블 간의 매핑을 자동화하는 기술**이다.  

| 개념 | 의미 |
|------|------|
| 클래스 | 데이터베이스의 테이블 |
| 객체의 필드 | 테이블의 컬럼 |
| 객체의 인스턴스 | 테이블의 한 행(Row) |

ORM을 통해 개발자는 SQL을 직접 작성하지 않고, **객체의 상태 변화**를 통해 데이터베이스를 제어할 수 있다.

---

## 4. JPA의 핵심 개념

### 4.1 엔티티(Entity)
- 데이터베이스 테이블과 매핑되는 자바 클래스  
- 각 인스턴스는 테이블의 한 행(Row)에 대응  
- `@Entity`로 선언하여 JPA가 관리하는 대상으로 지정

### 4.2 영속성 컨텍스트(Persistence Context)
- JPA가 엔티티를 관리하는 **임시 저장소(1차 캐시)**  
- 엔티티 매니저(EntityManager)가 여기에 객체를 보관하고 트랜잭션 단위로 관리함  
- 주요 기능  
  - **1차 캐시:** 동일 트랜잭션 내에서 같은 엔티티 재조회 시 캐시에서 조회  
  - **변경 감지(Dirty Checking):** 엔티티의 값이 바뀌면 자동으로 UPDATE SQL 생성  
  - **쓰기 지연(Write-behind):** 커밋 시점에 모아둔 SQL을 한 번에 전송  
  - **플러시(Flush):** 영속성 컨텍스트의 변경 내용을 DB에 반영

### 4.3 엔티티 생명주기

| 상태 | 설명 |
|------|------|
| 비영속 (new/transient) | 아직 영속성 컨텍스트에 저장되지 않은 상태 |
| 영속 (managed) | 영속성 컨텍스트에 저장되어 관리되는 상태 |
| 준영속 (detached) | 영속성 컨텍스트에서 분리된 상태 |
| 삭제 (removed) | 삭제 대상으로 등록된 상태 (커밋 시 실제 삭제) |

---

## 5. 매핑 및 연관관계 관리

### 5.1 기본 매핑 (Entity와 테이블 매핑)

- **클래스 ↔ 테이블**, **필드 ↔ 컬럼** 으로 매핑하여 객체와 데이터베이스 간 연결을 설정한다.  
- 매핑을 통해 JPA는 자바 객체를 테이블 행(Row)으로 변환하고, 반대로 데이터베이스의 값을 객체로 불러온다.  

#### 주요 매핑 어노테이션

| 어노테이션 | 설명 |
|-------------|------|
| `@Entity` | 이 클래스를 **JPA 엔티티(테이블과 매핑되는 객체)** 로 지정한다. JPA가 관리하는 영속 객체로 인식된다. |
| `@Table` | 엔티티와 매핑할 **테이블 이름**을 지정한다. 생략 시 클래스명과 동일한 테이블로 매핑된다. |
| `@Id` | **기본 키(Primary Key)** 로 사용할 필드에 지정한다. JPA는 이를 기준으로 엔티티를 식별한다. |
| `@Column` | 엔티티의 필드를 DB 컬럼과 매핑한다. 이름, 길이, 제약조건 등을 세부적으로 지정할 수 있다. |
| `@GeneratedValue` | **기본 키 생성 전략**을 설정한다. DB에서 키를 자동 생성할지, JPA가 관리할지를 결정한다. |

#### 기본 키 생성 전략

| 전략 | 설명 | 사용 예시 |
|------|------|-----------|
| `AUTO` | 데이터베이스 방언(Dialect)에 따라 자동으로 적절한 전략 선택 | 대부분의 환경에서 기본값 |
| `IDENTITY` | 기본 키 생성을 **DB에 위임** (`AUTO_INCREMENT`) | MySQL, SQL Server |
| `SEQUENCE` | **DB 시퀀스 객체**를 사용하여 키 생성 | Oracle, PostgreSQL |
| `TABLE` | 별도의 **키 전용 테이블**을 사용하여 키 관리 | 모든 DB 호환 가능하지만 성능 낮음 |

---

### 5.2 연관관계 매핑 (Relationship Mapping)

- 객체의 **참조 관계(association)** 를 데이터베이스의 **외래 키(Foreign Key)** 로 변환한다.  
- 객체 지향 설계에서는 다른 객체를 필드로 참조하지만, 관계형 DB는 외래 키로 관계를 표현하므로 JPA가 이를 자동 변환한다.  

#### 주요 연관관계 어노테이션

| 어노테이션 | 관계 유형 | 설명 |
|-------------|------------|------|
| `@OneToOne` | 1:1 | 한 엔티티가 하나의 다른 엔티티와 연결되는 관계 (예: 회원 ↔ 프로필) |
| `@OneToMany` | 1:N | 하나의 엔티티가 여러 엔티티를 참조하는 관계 (예: 회원 ↔ 주문목록) |
| `@ManyToOne` | N:1 | 여러 엔티티가 하나의 엔티티를 참조하는 관계 (예: 주문 ↔ 회원) |
| `@ManyToMany` | N:N | 다대다 관계, 중간 조인 테이블이 자동 생성됨 (실무에서는 별도 매핑 엔티티를 사용하는 게 일반적) |
| `@JoinColumn` | 외래 키 매핑 | 외래 키 컬럼명을 지정하고 관계의 주인(owner)을 명시한다. |

#### 연관관계 매핑 시 주의사항

- **관계의 주인(Owner)**: 외래 키를 실제로 가진 엔티티가 관계의 주인이며, 주인만이 관계를 수정할 수 있다.  
- **지연 로딩(LAZY)**: 필요할 때만 연관된 엔티티를 조회 (성능 최적화에 유리)  
- **즉시 로딩(EAGER)**: 엔티티 조회 시 연관 객체를 즉시 함께 조회 (N+1 문제 유발 가능)  

---

**영속성 전이(Cascade)**
- 부모 엔티티의 상태 변화가 자식 엔티티에도 전이되도록 설정 (`PERSIST`, `REMOVE` 등)

**고아 객체 제거(orphanRemoval)**
- 부모 컬렉션에서 제거된 자식 엔티티를 자동으로 DB에서 삭제

---

## 6. 데이터 조회: JPQL과 페치 조인

### 6.1 JPQL (Java Persistence Query Language)
- JPA에서 제공하는 객체 지향 쿼리 언어
- SQL과 유사하지만 **엔티티와 필드명 기준으로 작성**
- 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 함

### 6.2 페치 조인 (Fetch Join)
- JPQL에서 연관된 엔티티를 한 번에 함께 조회하는 방법  
- 지연 로딩으로 인한 N+1 문제를 해결할 때 사용  
- 단, 컬렉션 페치 조인 시 페이징 제약이 존재함

---

## 7. JPA와 트랜잭션

- JPA의 모든 데이터 변경(등록, 수정, 삭제)은 **트랜잭션 단위**로 처리된다.  
- `EntityManager`는 트랜잭션이 시작되면 영속성 컨텍스트를 초기화하고,  
  커밋 시점에 변경 내용을 데이터베이스에 반영한다.  
- 트랜잭션 커밋 → 플러시 → SQL 실행 → 커밋 확정 순으로 진행된다.

---

## 8. Spring Data JPA

- **Spring Data JPA**는 JPA를 더 쉽게 사용할 수 있도록 스프링이 제공하는 **추상화 라이브러리**이다.  
- 반복적인 CRUD 코드 없이 인터페이스만 정의하면 자동으로 구현체 생성.  
- 쿼리 메서드, 페이징, 정렬, 동적 쿼리(JPQL 기반) 등을 간단히 구현할 수 있다.

예) `findByName()`, `findByEmailContaining()` 등 메서드 이름만으로 쿼리 자동 생성.

---

## 9. 성능 및 주의사항

- **지연 로딩 기본 사용 (EAGER 금지)**  
  → 필요할 때만 데이터를 가져와 성능 최적화  
- **N+1 문제 주의**  
  → JPQL 페치 조인, `@EntityGraph` 등으로 해결  
- **트랜잭션 단위 유지**  
  → 영속성 컨텍스트는 트랜잭션 단위로 관리되므로,  
    Service 계층에 트랜잭션을 두는 것이 권장된다.  
- **양방향 관계 최소화**  
  → 무분별한 양방향 설정은 순환 참조 문제 유발 가능  

---

## 10. JPA의 장단점

### 장점
- SQL 직접 작성 감소 → 개발 생산성 향상  
- 객체 중심 설계 유지 → 코드 일관성  
- DB 교체 용이 → 높은 이식성  
- 캐시, 변경 감지, 쓰기 지연 등 성능 최적화 기능 내장  

### 단점
- 초기 학습 곡선이 큼  
- 복잡한 쿼리는 JPQL보다 SQL이 더 직관적일 수 있음  
- 잘못된 매핑 시 성능 저하 및 예기치 못한 SQL 발생 가능  

---

## 11. JPA 구현체

| 구현체 | 특징 |
|--------|------|
| **Hibernate** | 가장 널리 사용되는 구현체, 스프링 부트 기본 내장 |
| **EclipseLink** | 오라클 공식 구현체 |
| **DataNucleus** | 범용 JPA + JDO 지원 |

---

## 12. 정리

- JPA는 **자바 ORM 표준 스펙**이며, 객체와 데이터베이스 간 매핑을 자동화한다.  
- 핵심 요소는 **Entity, EntityManager, Persistence Context**  
- Hibernate는 가장 널리 사용되는 JPA 구현체이다.  
- 실무에서는 보통 **Spring Data JPA**와 함께 사용하여 생산성을 극대화한다.  

---

## 참고

- 김영한, *자바 ORM 표준 JPA 프로그래밍*  
- Velog: [JPA 기초 정리](https://velog.io/@coconenne/자바-ORM-표준-JPA-기본편핵심-내용-정리)  
- 티스토리: [JPA 핵심 개념 정리](https://maeng0830-note.tistory.com/16)  
- ws-pace 블로그: [Spring Data JPA 완전 정복](https://ws-pace.tistory.com/219)  
